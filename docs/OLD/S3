# LAZI AI - S3 Image Integration with CRM Layer

## Context & Current State

We have completed the pricebook data pipeline (RAW → MASTER sync at 100% for all entities), configured AWS S3 credentials, and created basic image infrastructure. However, several critical pieces are missing:

**Current State:**
- ✅ RAW tables: Full ServiceTitan data stored
- ✅ MASTER tables: Normalized data (services, materials, equipment, categories)
- ✅ S3 bucket created: `lazi-pricebook-images` in us-east-2
- ✅ AWS credentials configured in environment
- ✅ `imageStorage.js` service exists
- ❌ S3 bucket is EMPTY - no images migrated yet
- ❌ CRM tables not addressed - user edits have no home
- ❌ No image display logic for frontend
- ❌ No upload/delete/change functionality

**Tenant ID:** 3222348440

---

## OBJECTIVE

Build complete S3 image integration that:
1. Migrates existing ServiceTitan images to S3
2. Creates CRM edit tables for tracking custom image overrides
3. Provides image resolution logic (CRM custom → S3 migrated → ST fallback)
4. Enables image upload/delete/change from the CRM UI
5. Serves images efficiently throughout the application

---

## PART 1: Create CRM Edit Tables

The CRM layer stores local user edits before pushing to ServiceTitan. We need tables to track image overrides.

### 1.1 Create CRM Schema (if not exists)

```sql
CREATE SCHEMA IF NOT EXISTS crm;
```

### 1.2 Create Service Edits Table

```sql
CREATE TABLE IF NOT EXISTS crm.pricebook_service_edits (
  id SERIAL PRIMARY KEY,
  tenant_id TEXT NOT NULL,
  st_id BIGINT NOT NULL,
  
  -- Editable fields (NULL means use MASTER value)
  name TEXT,
  display_name TEXT,
  description TEXT,
  price DECIMAL(12,2),
  member_price DECIMAL(12,2),
  cost DECIMAL(12,2),
  hours DECIMAL(10,2),
  warranty TEXT,
  
  -- Image handling
  custom_image_url TEXT,           -- S3 URL if user uploaded custom image
  image_deleted BOOLEAN DEFAULT FALSE,  -- TRUE if user explicitly removed image
  
  -- Tracking
  edited_by TEXT,
  edited_at TIMESTAMPTZ DEFAULT NOW(),
  pushed_to_st BOOLEAN DEFAULT FALSE,
  pushed_at TIMESTAMPTZ,
  
  -- Constraints
  CONSTRAINT service_edits_tenant_st UNIQUE (tenant_id, st_id)
);

CREATE INDEX idx_service_edits_tenant ON crm.pricebook_service_edits(tenant_id);
CREATE INDEX idx_service_edits_st_id ON crm.pricebook_service_edits(st_id);
CREATE INDEX idx_service_edits_not_pushed ON crm.pricebook_service_edits(tenant_id) WHERE pushed_to_st = FALSE;
```

### 1.3 Create Material Edits Table

```sql
CREATE TABLE IF NOT EXISTS crm.pricebook_material_edits (
  id SERIAL PRIMARY KEY,
  tenant_id TEXT NOT NULL,
  st_id BIGINT NOT NULL,
  
  -- Editable fields
  name TEXT,
  display_name TEXT,
  description TEXT,
  cost DECIMAL(12,4),
  price DECIMAL(12,2),
  
  -- Image handling
  custom_image_url TEXT,
  image_deleted BOOLEAN DEFAULT FALSE,
  
  -- Tracking
  edited_by TEXT,
  edited_at TIMESTAMPTZ DEFAULT NOW(),
  pushed_to_st BOOLEAN DEFAULT FALSE,
  pushed_at TIMESTAMPTZ,
  
  CONSTRAINT material_edits_tenant_st UNIQUE (tenant_id, st_id)
);

CREATE INDEX idx_material_edits_tenant ON crm.pricebook_material_edits(tenant_id);
CREATE INDEX idx_material_edits_st_id ON crm.pricebook_material_edits(st_id);
```

### 1.4 Create Equipment Edits Table

```sql
CREATE TABLE IF NOT EXISTS crm.pricebook_equipment_edits (
  id SERIAL PRIMARY KEY,
  tenant_id TEXT NOT NULL,
  st_id BIGINT NOT NULL,
  
  -- Editable fields
  name TEXT,
  display_name TEXT,
  description TEXT,
  cost DECIMAL(12,2),
  price DECIMAL(12,2),
  
  -- Image handling
  custom_image_url TEXT,
  image_deleted BOOLEAN DEFAULT FALSE,
  
  -- Tracking
  edited_by TEXT,
  edited_at TIMESTAMPTZ DEFAULT NOW(),
  pushed_to_st BOOLEAN DEFAULT FALSE,
  pushed_at TIMESTAMPTZ,
  
  CONSTRAINT equipment_edits_tenant_st UNIQUE (tenant_id, st_id)
);

CREATE INDEX idx_equipment_edits_tenant ON crm.pricebook_equipment_edits(tenant_id);
```

### 1.5 Create Category Edits Table

```sql
CREATE TABLE IF NOT EXISTS crm.pricebook_category_edits (
  id SERIAL PRIMARY KEY,
  tenant_id TEXT NOT NULL,
  st_id BIGINT NOT NULL,
  
  -- Editable fields
  name TEXT,
  display_name TEXT,
  description TEXT,
  
  -- Image handling
  custom_image_url TEXT,
  image_deleted BOOLEAN DEFAULT FALSE,
  
  -- Tracking
  edited_by TEXT,
  edited_at TIMESTAMPTZ DEFAULT NOW(),
  pushed_to_st BOOLEAN DEFAULT FALSE,
  pushed_at TIMESTAMPTZ,
  
  CONSTRAINT category_edits_tenant_st UNIQUE (tenant_id, st_id)
);

CREATE INDEX idx_category_edits_tenant ON crm.pricebook_category_edits(tenant_id);
```

---

## PART 2: Add S3 Image Columns to MASTER Tables

```sql
-- Services
ALTER TABLE master.pricebook_services 
ADD COLUMN IF NOT EXISTS s3_image_url TEXT,
ADD COLUMN IF NOT EXISTS s3_image_key TEXT,
ADD COLUMN IF NOT EXISTS image_migrated_at TIMESTAMPTZ;

-- Materials
ALTER TABLE master.pricebook_materials 
ADD COLUMN IF NOT EXISTS s3_image_url TEXT,
ADD COLUMN IF NOT EXISTS s3_image_key TEXT,
ADD COLUMN IF NOT EXISTS image_migrated_at TIMESTAMPTZ;

-- Equipment
ALTER TABLE master.pricebook_equipment 
ADD COLUMN IF NOT EXISTS s3_image_url TEXT,
ADD COLUMN IF NOT EXISTS s3_image_key TEXT,
ADD COLUMN IF NOT EXISTS image_migrated_at TIMESTAMPTZ;

-- Categories
ALTER TABLE master.pricebook_categories 
ADD COLUMN IF NOT EXISTS s3_image_url TEXT,
ADD COLUMN IF NOT EXISTS s3_image_key TEXT,
ADD COLUMN IF NOT EXISTS image_migrated_at TIMESTAMPTZ;

-- Indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_services_s3_image ON master.pricebook_services(tenant_id) WHERE s3_image_url IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_materials_s3_image ON master.pricebook_materials(tenant_id) WHERE s3_image_url IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_equipment_s3_image ON master.pricebook_equipment(tenant_id) WHERE s3_image_url IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_categories_s3_image ON master.pricebook_categories(tenant_id) WHERE s3_image_url IS NOT NULL;
```

---

## PART 3: Image Resolution Service

Create a service that resolves the correct image URL based on priority:
1. CRM custom image (user uploaded)
2. S3 migrated image (from ServiceTitan)
3. ServiceTitan original URL (fallback)

**File: `/app/src/services/imageResolver.js`**

```javascript
import pool from '../db/pool.js';

/**
 * Image Resolution Priority:
 * 1. CRM custom_image_url (user uploaded custom image)
 * 2. MASTER s3_image_url (migrated from ServiceTitan)
 * 3. MASTER assets[0].url (original ServiceTitan URL)
 * 4. null (no image)
 */

const ENTITY_CONFIG = {
  services: {
    masterTable: 'master.pricebook_services',
    crmTable: 'crm.pricebook_service_edits',
    stImageField: "assets->0->>'url'",
  },
  materials: {
    masterTable: 'master.pricebook_materials',
    crmTable: 'crm.pricebook_material_edits',
    stImageField: "image_url",
  },
  equipment: {
    masterTable: 'master.pricebook_equipment',
    crmTable: 'crm.pricebook_equipment_edits',
    stImageField: "image_url",
  },
  categories: {
    masterTable: 'master.pricebook_categories',
    crmTable: 'crm.pricebook_category_edits',
    stImageField: "image_url",
  },
};

/**
 * Resolve image URL for a single entity
 */
export async function resolveImageUrl(entityType, stId, tenantId) {
  const config = ENTITY_CONFIG[entityType];
  if (!config) throw new Error(`Unknown entity type: ${entityType}`);

  const query = `
    SELECT 
      m.st_id,
      m.s3_image_url as migrated_url,
      m.${config.stImageField} as original_url,
      e.custom_image_url,
      e.image_deleted
    FROM ${config.masterTable} m
    LEFT JOIN ${config.crmTable} e ON m.st_id = e.st_id AND m.tenant_id = e.tenant_id
    WHERE m.st_id = $1 AND m.tenant_id = $2
  `;

  const result = await pool.query(query, [stId, tenantId]);
  
  if (result.rows.length === 0) return null;
  
  const row = result.rows[0];
  
  // If user explicitly deleted the image
  if (row.image_deleted) return null;
  
  // Priority: CRM custom → S3 migrated → ST original
  return row.custom_image_url || row.migrated_url || row.original_url || null;
}

/**
 * Resolve image URLs for multiple entities (batch)
 */
export async function resolveImageUrls(entityType, stIds, tenantId) {
  const config = ENTITY_CONFIG[entityType];
  if (!config) throw new Error(`Unknown entity type: ${entityType}`);

  const query = `
    SELECT 
      m.st_id,
      m.s3_image_url as migrated_url,
      m.${config.stImageField} as original_url,
      e.custom_image_url,
      e.image_deleted
    FROM ${config.masterTable} m
    LEFT JOIN ${config.crmTable} e ON m.st_id = e.st_id AND m.tenant_id = e.tenant_id
    WHERE m.st_id = ANY($1) AND m.tenant_id = $2
  `;

  const result = await pool.query(query, [stIds, tenantId]);
  
  const imageMap = {};
  for (const row of result.rows) {
    if (row.image_deleted) {
      imageMap[row.st_id] = null;
    } else {
      imageMap[row.st_id] = row.custom_image_url || row.migrated_url || row.original_url || null;
    }
  }
  
  return imageMap;
}

/**
 * Get image info with all URLs for debugging/admin
 */
export async function getImageInfo(entityType, stId, tenantId) {
  const config = ENTITY_CONFIG[entityType];
  if (!config) throw new Error(`Unknown entity type: ${entityType}`);

  const query = `
    SELECT 
      m.st_id,
      m.name,
      m.s3_image_url as migrated_url,
      m.s3_image_key,
      m.image_migrated_at,
      m.${config.stImageField} as original_url,
      e.custom_image_url,
      e.image_deleted,
      e.edited_at as custom_image_uploaded_at
    FROM ${config.masterTable} m
    LEFT JOIN ${config.crmTable} e ON m.st_id = e.st_id AND m.tenant_id = e.tenant_id
    WHERE m.st_id = $1 AND m.tenant_id = $2
  `;

  const result = await pool.query(query, [stId, tenantId]);
  
  if (result.rows.length === 0) return null;
  
  const row = result.rows[0];
  
  return {
    st_id: row.st_id,
    name: row.name,
    resolved_url: row.image_deleted ? null : (row.custom_image_url || row.migrated_url || row.original_url),
    sources: {
      custom: row.custom_image_url,
      migrated: row.migrated_url,
      original: row.original_url,
    },
    s3_key: row.s3_image_key,
    is_deleted: row.image_deleted,
    migrated_at: row.image_migrated_at,
    custom_uploaded_at: row.custom_image_uploaded_at,
  };
}

export default {
  resolveImageUrl,
  resolveImageUrls,
  getImageInfo,
};
```

---

## PART 4: Image Management Routes

**File: `/app/src/routes/pricebook-image-manager.js`**

```javascript
import express from 'express';
import multer from 'multer';
import pool from '../db/pool.js';
import { uploadImage, deleteImage, generateImageKey } from '../services/imageStorage.js';
import { resolveImageUrl, resolveImageUrls, getImageInfo } from '../services/imageResolver.js';

const router = express.Router();

// Configure multer for memory storage (we'll upload to S3)
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB max
  fileFilter: (req, file, cb) => {
    const allowed = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (allowed.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only JPEG, PNG, WebP, and GIF allowed.'));
    }
  },
});

const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

const VALID_ENTITY_TYPES = ['services', 'materials', 'equipment', 'categories'];
const CRM_TABLES = {
  services: 'crm.pricebook_service_edits',
  materials: 'crm.pricebook_material_edits',
  equipment: 'crm.pricebook_equipment_edits',
  categories: 'crm.pricebook_category_edits',
};

/**
 * GET /api/pricebook/images/:entityType/:stId
 * Get resolved image URL for an entity
 */
router.get('/:entityType/:stId', asyncHandler(async (req, res) => {
  const { entityType, stId } = req.params;
  const tenantId = req.headers['x-tenant-id'];

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  const imageUrl = await resolveImageUrl(entityType, stId, tenantId);
  
  res.json({
    success: true,
    st_id: stId,
    entity_type: entityType,
    image_url: imageUrl,
  });
}));

/**
 * GET /api/pricebook/images/:entityType/:stId/info
 * Get detailed image info (all sources)
 */
router.get('/:entityType/:stId/info', asyncHandler(async (req, res) => {
  const { entityType, stId } = req.params;
  const tenantId = req.headers['x-tenant-id'];

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  const info = await getImageInfo(entityType, stId, tenantId);
  
  if (!info) {
    return res.status(404).json({ success: false, error: 'Entity not found' });
  }
  
  res.json({ success: true, ...info });
}));

/**
 * POST /api/pricebook/images/:entityType/:stId/batch
 * Get resolved image URLs for multiple entities
 */
router.post('/:entityType/batch', asyncHandler(async (req, res) => {
  const { entityType } = req.params;
  const { st_ids } = req.body;
  const tenantId = req.headers['x-tenant-id'];

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  if (!Array.isArray(st_ids) || st_ids.length === 0) {
    return res.status(400).json({ success: false, error: 'st_ids array required' });
  }

  if (st_ids.length > 100) {
    return res.status(400).json({ success: false, error: 'Max 100 IDs per request' });
  }

  const imageMap = await resolveImageUrls(entityType, st_ids, tenantId);
  
  res.json({
    success: true,
    entity_type: entityType,
    images: imageMap,
  });
}));

/**
 * POST /api/pricebook/images/:entityType/:stId/upload
 * Upload a custom image for an entity
 */
router.post('/:entityType/:stId/upload', upload.single('image'), asyncHandler(async (req, res) => {
  const { entityType, stId } = req.params;
  const tenantId = req.headers['x-tenant-id'];
  const userId = req.headers['x-user-id'] || 'unknown';

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  if (!req.file) {
    return res.status(400).json({ success: false, error: 'No image file provided' });
  }

  // Generate S3 key for custom image
  const s3Key = generateImageKey(tenantId, `${entityType}/custom`, req.file.originalname);
  
  // Upload to S3
  const s3Url = await uploadImage(s3Key, req.file.buffer, req.file.mimetype);
  
  // Upsert into CRM edit table
  const crmTable = CRM_TABLES[entityType];
  await pool.query(`
    INSERT INTO ${crmTable} (tenant_id, st_id, custom_image_url, image_deleted, edited_by, edited_at)
    VALUES ($1, $2, $3, FALSE, $4, NOW())
    ON CONFLICT (tenant_id, st_id) DO UPDATE SET
      custom_image_url = $3,
      image_deleted = FALSE,
      edited_by = $4,
      edited_at = NOW()
  `, [tenantId, stId, s3Url, userId]);

  res.json({
    success: true,
    message: 'Image uploaded successfully',
    st_id: stId,
    entity_type: entityType,
    image_url: s3Url,
    s3_key: s3Key,
  });
}));

/**
 * DELETE /api/pricebook/images/:entityType/:stId
 * Delete/remove image for an entity (marks as deleted, doesn't remove from S3)
 */
router.delete('/:entityType/:stId', asyncHandler(async (req, res) => {
  const { entityType, stId } = req.params;
  const tenantId = req.headers['x-tenant-id'];
  const userId = req.headers['x-user-id'] || 'unknown';
  const { delete_from_s3 } = req.query; // Optional: actually delete from S3

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  // Get current custom image URL before deletion
  const crmTable = CRM_TABLES[entityType];
  const existing = await pool.query(
    `SELECT custom_image_url FROM ${crmTable} WHERE tenant_id = $1 AND st_id = $2`,
    [tenantId, stId]
  );

  // Mark image as deleted in CRM
  await pool.query(`
    INSERT INTO ${crmTable} (tenant_id, st_id, image_deleted, custom_image_url, edited_by, edited_at)
    VALUES ($1, $2, TRUE, NULL, $3, NOW())
    ON CONFLICT (tenant_id, st_id) DO UPDATE SET
      image_deleted = TRUE,
      custom_image_url = NULL,
      edited_by = $3,
      edited_at = NOW()
  `, [tenantId, stId, userId]);

  // Optionally delete from S3
  if (delete_from_s3 === 'true' && existing.rows[0]?.custom_image_url) {
    const url = existing.rows[0].custom_image_url;
    // Extract key from URL
    const key = url.split('.amazonaws.com/')[1];
    if (key) {
      try {
        await deleteImage(key);
      } catch (e) {
        console.error('Failed to delete from S3:', e);
      }
    }
  }

  res.json({
    success: true,
    message: 'Image removed',
    st_id: stId,
    entity_type: entityType,
  });
}));

/**
 * POST /api/pricebook/images/:entityType/:stId/restore
 * Restore original image (remove custom override and deletion flag)
 */
router.post('/:entityType/:stId/restore', asyncHandler(async (req, res) => {
  const { entityType, stId } = req.params;
  const tenantId = req.headers['x-tenant-id'];
  const userId = req.headers['x-user-id'] || 'unknown';

  if (!VALID_ENTITY_TYPES.includes(entityType)) {
    return res.status(400).json({ success: false, error: 'Invalid entity type' });
  }

  const crmTable = CRM_TABLES[entityType];
  
  // Clear custom image and deletion flag
  await pool.query(`
    UPDATE ${crmTable}
    SET custom_image_url = NULL,
        image_deleted = FALSE,
        edited_by = $3,
        edited_at = NOW()
    WHERE tenant_id = $1 AND st_id = $2
  `, [tenantId, stId, userId]);

  // Get the restored URL
  const imageUrl = await resolveImageUrl(entityType, stId, tenantId);

  res.json({
    success: true,
    message: 'Image restored to original',
    st_id: stId,
    entity_type: entityType,
    image_url: imageUrl,
  });
}));

export default router;
```

---

## PART 5: Image Migration from ServiceTitan to S3

Update the existing `/app/src/routes/pricebook-images.js` to actually migrate images:

**File: `/app/src/routes/pricebook-images.js`** (Replace existing)

```javascript
import express from 'express';
import pool from '../db/pool.js';
import { uploadImage, generateImageKey } from '../services/imageStorage.js';

const router = express.Router();

const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

/**
 * GET /api/pricebook/images/migrate/status
 * Check migration status for all entity types
 */
router.get('/migrate/status', asyncHandler(async (req, res) => {
  const tenantId = req.headers['x-tenant-id'];

  const stats = {};

  // Services
  const servicesResult = await pool.query(`
    SELECT 
      COUNT(*) FILTER (WHERE s3_image_url IS NOT NULL) as migrated,
      COUNT(*) FILTER (WHERE s3_image_url IS NULL AND assets IS NOT NULL AND jsonb_array_length(assets) > 0) as pending,
      COUNT(*) FILTER (WHERE assets IS NULL OR jsonb_array_length(assets) = 0) as no_image
    FROM master.pricebook_services
    WHERE tenant_id = $1
  `, [tenantId]);
  stats.services = servicesResult.rows[0];

  // Materials
  const materialsResult = await pool.query(`
    SELECT 
      COUNT(*) FILTER (WHERE s3_image_url IS NOT NULL) as migrated,
      COUNT(*) FILTER (WHERE s3_image_url IS NULL AND image_url IS NOT NULL) as pending,
      COUNT(*) FILTER (WHERE image_url IS NULL) as no_image
    FROM master.pricebook_materials
    WHERE tenant_id = $1
  `, [tenantId]);
  stats.materials = materialsResult.rows[0];

  // Equipment
  const equipmentResult = await pool.query(`
    SELECT 
      COUNT(*) FILTER (WHERE s3_image_url IS NOT NULL) as migrated,
      COUNT(*) FILTER (WHERE s3_image_url IS NULL AND image_url IS NOT NULL) as pending,
      COUNT(*) FILTER (WHERE image_url IS NULL) as no_image
    FROM master.pricebook_equipment
    WHERE tenant_id = $1
  `, [tenantId]);
  stats.equipment = equipmentResult.rows[0];

  // Categories
  const categoriesResult = await pool.query(`
    SELECT 
      COUNT(*) FILTER (WHERE s3_image_url IS NOT NULL) as migrated,
      COUNT(*) FILTER (WHERE s3_image_url IS NULL AND image_url IS NOT NULL) as pending,
      COUNT(*) FILTER (WHERE image_url IS NULL) as no_image
    FROM master.pricebook_categories
    WHERE tenant_id = $1
  `, [tenantId]);
  stats.categories = categoriesResult.rows[0];

  res.json({ success: true, tenant_id: tenantId, stats });
}));

/**
 * POST /api/pricebook/images/migrate/services
 * Migrate service images from ServiceTitan to S3
 */
router.post('/migrate/services', asyncHandler(async (req, res) => {
  const tenantId = req.headers['x-tenant-id'];
  const { limit = 50 } = req.body;

  // Get services with images that haven't been migrated
  const services = await pool.query(`
    SELECT st_id, name, assets
    FROM master.pricebook_services
    WHERE tenant_id = $1
      AND assets IS NOT NULL
      AND jsonb_array_length(assets) > 0
      AND s3_image_url IS NULL
    LIMIT $2
  `, [tenantId, limit]);

  const results = { migrated: 0, failed: 0, errors: [] };

  for (const service of services.rows) {
    try {
      const assets = service.assets;
      const imageUrl = assets[0]?.url;
      
      if (!imageUrl) continue;

      // Construct full ServiceTitan image URL
      const fullUrl = imageUrl.startsWith('http') 
        ? imageUrl 
        : `https://go.servicetitan.com/${imageUrl}`;

      // Fetch image from ServiceTitan
      const response = await fetch(fullUrl, { redirect: 'follow' });
      
      if (!response.ok) {
        results.failed++;
        results.errors.push({ st_id: service.st_id, error: `HTTP ${response.status}` });
        continue;
      }

      const buffer = Buffer.from(await response.arrayBuffer());
      const contentType = response.headers.get('content-type') || 'image/jpeg';
      const ext = contentType.includes('png') ? 'png' : 'jpg';

      // Generate S3 key and upload
      const s3Key = `${tenantId}/services/${service.st_id}.${ext}`;
      const s3Url = await uploadImage(s3Key, buffer, contentType);

      // Update database
      await pool.query(`
        UPDATE master.pricebook_services
        SET s3_image_url = $1, s3_image_key = $2, image_migrated_at = NOW()
        WHERE st_id = $3 AND tenant_id = $4
      `, [s3Url, s3Key, service.st_id, tenantId]);

      results.migrated++;
      console.log(`Migrated service ${service.st_id}: ${service.name}`);

    } catch (error) {
      results.failed++;
      results.errors.push({ st_id: service.st_id, error: error.message });
    }
  }

  res.json({
    success: true,
    message: `Migration complete: ${results.migrated} migrated, ${results.failed} failed`,
    ...results,
  });
}));

/**
 * POST /api/pricebook/images/migrate/materials
 * Migrate material images to S3
 */
router.post('/migrate/materials', asyncHandler(async (req, res) => {
  const tenantId = req.headers['x-tenant-id'];
  const { limit = 50 } = req.body;

  const materials = await pool.query(`
    SELECT st_id, name, image_url
    FROM master.pricebook_materials
    WHERE tenant_id = $1
      AND image_url IS NOT NULL
      AND s3_image_url IS NULL
    LIMIT $2
  `, [tenantId, limit]);

  const results = { migrated: 0, failed: 0, errors: [] };

  for (const material of materials.rows) {
    try {
      const fullUrl = material.image_url.startsWith('http')
        ? material.image_url
        : `https://go.servicetitan.com/${material.image_url}`;

      const response = await fetch(fullUrl, { redirect: 'follow' });
      if (!response.ok) {
        results.failed++;
        continue;
      }

      const buffer = Buffer.from(await response.arrayBuffer());
      const contentType = response.headers.get('content-type') || 'image/jpeg';
      const ext = contentType.includes('png') ? 'png' : 'jpg';

      const s3Key = `${tenantId}/materials/${material.st_id}.${ext}`;
      const s3Url = await uploadImage(s3Key, buffer, contentType);

      await pool.query(`
        UPDATE master.pricebook_materials
        SET s3_image_url = $1, s3_image_key = $2, image_migrated_at = NOW()
        WHERE st_id = $3 AND tenant_id = $4
      `, [s3Url, s3Key, material.st_id, tenantId]);

      results.migrated++;
    } catch (error) {
      results.failed++;
      results.errors.push({ st_id: material.st_id, error: error.message });
    }
  }

  res.json({ success: true, ...results });
}));

/**
 * POST /api/pricebook/images/migrate/all
 * Migrate all entity types
 */
router.post('/migrate/all', asyncHandler(async (req, res) => {
  const tenantId = req.headers['x-tenant-id'];
  const { limit_per_type = 25 } = req.body;

  res.json({
    success: true,
    message: 'Use individual migration endpoints for better control',
    endpoints: [
      'POST /api/pricebook/images/migrate/services',
      'POST /api/pricebook/images/migrate/materials',
      'POST /api/pricebook/images/migrate/equipment',
      'POST /api/pricebook/images/migrate/categories',
    ],
  });
}));

export default router;
```

---

## PART 6: Update API GET Endpoints to Include Resolved Images

Update existing GET endpoints to use the image resolver. For example, update the services GET endpoint:

**In `/app/src/routes/pricebook.routes.js` or similar:**

```javascript
import { resolveImageUrl, resolveImageUrls } from '../services/imageResolver.js';

// When returning a single service:
router.get('/services/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const tenantId = req.headers['x-tenant-id'];

  // ... existing query to get service ...

  // Add resolved image URL
  const imageUrl = await resolveImageUrl('services', id, tenantId);
  
  res.json({
    ...service,
    resolved_image_url: imageUrl,
  });
}));

// When returning a list of services:
router.get('/services', asyncHandler(async (req, res) => {
  const tenantId = req.headers['x-tenant-id'];

  // ... existing query to get services list ...
  
  // Batch resolve images
  const stIds = services.map(s => s.st_id);
  const imageMap = await resolveImageUrls('services', stIds, tenantId);
  
  // Add image URLs to each service
  const servicesWithImages = services.map(s => ({
    ...s,
    resolved_image_url: imageMap[s.st_id] || null,
  }));

  res.json({ services: servicesWithImages });
}));
```

---

## PART 7: Register Routes in app.js

Add to `/app/src/app.js`:

```javascript
import pricebookImageManagerRoutes from './routes/pricebook-image-manager.js';

// ... other imports ...

// Register routes
app.use('/api/pricebook/images', pricebookImageManagerRoutes);
```

---

## PART 8: Install Required Dependencies

```bash
npm install multer --save
```

---

## PART 9: Testing Checklist

### 9.1 Create CRM Tables
```bash
# Run the SQL from Part 1 against your database
```

### 9.2 Add MASTER Table Columns
```bash
# Run the SQL from Part 2 against your database
```

### 9.3 Test Migration Status
```bash
curl -H "x-tenant-id: 3222348440" \
  http://localhost:3001/api/pricebook/images/migrate/status
```

### 9.4 Migrate Some Service Images
```bash
curl -X POST -H "x-tenant-id: 3222348440" \
  -H "Content-Type: application/json" \
  -d '{"limit": 10}' \
  http://localhost:3001/api/pricebook/images/migrate/services
```

### 9.5 Check S3 Bucket
```bash
aws s3 ls s3://lazi-pricebook-images/3222348440/services/
```

### 9.6 Test Image Resolution
```bash
curl -H "x-tenant-id: 3222348440" \
  http://localhost:3001/api/pricebook/images/services/61884945
```

### 9.7 Test Image Upload
```bash
curl -X POST -H "x-tenant-id: 3222348440" \
  -F "image=@test-image.jpg" \
  http://localhost:3001/api/pricebook/images/services/61884945/upload
```

### 9.8 Test Image Delete
```bash
curl -X DELETE -H "x-tenant-id: 3222348440" \
  http://localhost:3001/api/pricebook/images/services/61884945
```

### 9.9 Test Image Restore
```bash
curl -X POST -H "x-tenant-id: 3222348440" \
  http://localhost:3001/api/pricebook/images/services/61884945/restore
```

---

## Summary of Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| Database | CREATE | CRM edit tables (4 tables) |
| Database | ALTER | Add s3_image_url columns to MASTER tables |
| `/app/src/services/imageResolver.js` | CREATE | Image URL resolution logic |
| `/app/src/routes/pricebook-image-manager.js` | CREATE | Upload/delete/restore endpoints |
| `/app/src/routes/pricebook-images.js` | REPLACE | Migration endpoints |
| `/app/src/app.js` | MODIFY | Register new routes |
| `package.json` | MODIFY | Add multer dependency |

---

## Expected Outcome

After implementation:
1. ✅ CRM tables exist for tracking user edits including image overrides
2. ✅ Images can be migrated from ServiceTitan to S3
3. ✅ Frontend can resolve correct image URL via API
4. ✅ Users can upload custom images (stored in S3, tracked in CRM)
5. ✅ Users can delete images (marked in CRM)
6. ✅ Users can restore original images
7. ✅ Image resolution follows priority: CRM custom → S3 migrated → ST original

---

## API Endpoints Summary

```
Image Resolution:
GET  /api/pricebook/images/:entityType/:stId           - Get resolved image URL
GET  /api/pricebook/images/:entityType/:stId/info      - Get detailed image info
POST /api/pricebook/images/:entityType/batch           - Batch resolve URLs

Image Management:
POST   /api/pricebook/images/:entityType/:stId/upload  - Upload custom image
DELETE /api/pricebook/images/:entityType/:stId         - Delete/hide image
POST   /api/pricebook/images/:entityType/:stId/restore - Restore original

Migration:
GET  /api/pricebook/images/migrate/status              - Migration status
POST /api/pricebook/images/migrate/services            - Migrate service images
POST /api/pricebook/images/migrate/materials           - Migrate material images
```